/// Tags : centroid decomposition
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 4, LOG = 20, oo = 1e9 + 7;
int n, Q;
multiset<int> adj[N];

int par[N][LOG+4], hei[N]; 

void DFS(int parent, int u) {
    par[u][0] = parent; hei[u] = hei[parent] + 1;
    for (auto v : adj[u]) if (v != parent) DFS(u, v);
}
void Build_LCA() {
    for (int j = 1; j <= LOG; ++j) for (int i = 1; i <= n; ++i) 
        par[i][j] = par[par[i][j-1]][j-1];
}
int LCA(int u, int v) {
    if (hei[u] < hei[v]) swap(u, v);
    for (int i = LOG; i >= 0; --i) 
        if (hei[u] - (1<<i) >= hei[v]) u = par[u][i];
    if (u == v) return u;
    for (int i = LOG; i >= 0; --i) 
        if (par[u][i] != 0 && par[v][i] != 0 && par[u][i] != par[v][i]) {
            u = par[u][i]; v = par[v][i];
        }
    return par[u][0];
}
int getDist(int u, int v) { 
    int parent = LCA(u, v);
    return hei[u] + hei[v] - 2*hei[parent];
}

int numChild[N], total;

void DFS_SubTree(int parent, int u) {
    numChild[u] = 1; 
    for (auto v : adj[u]) if (v != parent) {
        DFS_SubTree(u, v);
        numChild[u] += numChild[v];
    }
}

int Find_centroid(int parent, int u) {
    for (auto v : adj[u]) 
        if (v != parent && numChild[v] > total/2) return Find_centroid(u, v);
    return u;
}

int dad[N];

void Centroid_Decompose(int parent, int u) {
    DFS_SubTree(parent, u); total = numChild[u];

    int centroid = Find_centroid(parent, u);
    dad[centroid] = parent;

    for (auto v : adj[centroid]) if (v != parent) {
        adj[v].erase(centroid);
        Centroid_Decompose(centroid, v);
    }
    adj[centroid].clear();
}

int minDist[N];

void update(int ver) {
    int u = ver;
    while (u != 0) {
        minDist[u] = min(minDist[u], getDist(u, ver));
        u = dad[u];
    }
}
int get(int ver) {
    int u = ver, res = oo;
    while (u != 0) {
        res = min(res, minDist[u] + getDist(ver, u));
        u = dad[u];
    } 
    return res;
}

void sol() {
    DFS(0, 1);
    Build_LCA();

    Centroid_Decompose(0, 1);

    for (int i = 1; i <= n; ++i) minDist[i] = oo;
    update(1);

    int type, u;
    while (Q--) {
        cin >> type >> u;
        if (type == 1) update(u);
        else cout << get(u) << '\n';
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    if (fopen("input.txt", "r")) 
        freopen("input.txt", "r", stdin);

    cin >> n >> Q;
    int u, v;
    for (int i = 1; i < n; ++i) {
        cin >> u >> v;
        adj[u].insert(v); adj[v].insert(u);
    }

    sol();

    return 0;
}
